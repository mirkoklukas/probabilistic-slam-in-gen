# # # # # # # # # # # # # # # # # # # 
#                                   # 
#   This is an auto-generated file  # 
#   based on the jupyter notebook   # 
#
#   >   ``41 -SLAM Tutorial - Part 1.ipynb''
#
#                                   #
# # # # # # # # # # # # # # # # # # #

push!(LOAD_PATH, "../src");
push!(LOAD_PATH, ENV["probcomp"]*"/Gen-Distribution-Zoo/src");
using BenchmarkTools;
using CUDA
using LaTeXStrings
using Colors, Plots, Images;
col = palette(:default);
(cgrad::PlotUtils.ContinuousColorGradient)(xs::Vector{Vector{Float64}}) = [cgrad[x] for x in xs];
(cgrad::PlotUtils.ContinuousColorGradient)(m::Matrix{Float64}) = reshape(cgrad[m[:]], size(m));
using Gen
using Fmt # Python-style f-strings
using MyUtils
using GenDistributionZoo: diagnormal
include("../../src/pose.jl"); # autogenerated from: "../src/pose.jl"
include("plotting.jl"); # autogenerated from: "src/plotting.jl"

include("csail_data.jl"); # autogenerated from: "src/csail_data.jl"

@gen function control_prior_model(dx_noise=0.25, dhd_noise=45/360*2π)
    dx  ~ diagnormal([0;0], [dx_noise, dx_noise])
    dhd ~ normal(0, dhd_noise)
    return Control(dx, dhd)
end;

"""
    q = motion_model(p, u, x_noise, hd_noise)

Sample a new pose `q` given the previous pose `p`,
some control data `u = Control(dx, dhd)`, and noise levels
`x_noise` and `hd_noise`.
"""
@gen function motion_model(p, u, x_noise, hd_noise)
    dx, dhd = u.dx, u.dhd
    x   ~ diagnormal(p.x  + dx , [x_noise, x_noise])
    hd  ~ normal(p.hd + dhd, hd_noise)
    return Pose(x, hd)
end;

include("sensor_distribution.jl"); # autogenerated from: "src/sensor_distribution.jl"
include("../../src/cuda_raycaster_point_cloud_b.jl"); # autogenerated from: "../src/cuda_raycaster_point_cloud_b.jl"

@doc sensordist_cu

"""
```julia
    x = sensor_model(p, ys, w, s_noise, outlier, outliver_vol, zmax)::Vector{Vector{Float}}
```
"""
@gen function sensor_model(p, ys, w, s_noise, outlier, outliver_vol, zmax)
    p_  = CuArray(Vector(p))
    ps_ = reshape(p_, 1, 3)
    ys_ = CuArray(stack(ys))
    as_ = CuArray(_as)

    # Deterministic measurement at
    # poses `ps_` given the point-cloud-map `ys_`
    zs_ = cast_cu(ps_, ys_; fov=π, zmax=zmax, cell_rad=0.01)

    # Compute gaussian mixture components `y_tilde_`, and
    # sample an observation
    mixture_args = (wrap=false, fill=true, fill_val_z=Inf, fill_val_a=Inf)
    y_tilde_ = get_2d_mixture_components(zs_, as_, w; mixture_args...)[1,:,:,:]
    x = {:x} ~ sensordist_cu(y_tilde_, s_noise, outlier, outliver_vol)

    return x, Array(zs_[1,:])
end;

@gen function step_model(m,
                         u, x_noise, hd_noise,
                         w, s_noise, outlier, outliver_vol, zmax)

        p  = Pose()
        p′ = {:pose}   ~ motion_model(p, u, x_noise, hd_noise)
        x′,z′ = {:sensor} ~ sensor_model(p′, m, w, s_noise, outlier, outliver_vol, zmax)

    return Dict(
        :p =>p′,
        :x => x′,
        :z => z′
    )
end;

get_pose(tr) = tr[:pose]
get_obs(tr)  = tr[:sensor]

function constraints(t::Int)
    ch = choicemap((:sensor => :x) => _ys[t])
    return ch
end
