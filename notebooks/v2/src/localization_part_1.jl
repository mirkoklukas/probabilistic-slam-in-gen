# # # # # # # # # # # # # # # # # # # 
#                                   # 
#   This is an auto-generated file  # 
#   based on the jupyter notebook   # 
#
#   >   ``51 Localization Tutorial - Part 1.ipynb''
#
#                                   #
# # # # # # # # # # # # # # # # # # #

push!(LOAD_PATH, "../src");
push!(LOAD_PATH, ENV["probcomp"]*"/Gen-Distribution-Zoo/src");
using BenchmarkTools;
using CUDA
using LaTeXStrings
using Colors, Plots, Images;
col = palette(:default);
(cgrad::PlotUtils.ContinuousColorGradient)(xs::Vector{Vector{Float64}}) = [cgrad[x] for x in xs];
(cgrad::PlotUtils.ContinuousColorGradient)(m::Matrix{Float64}) = reshape(cgrad[m[:]], size(m));
using Gen
using Fmt # Python-style f-strings
using MyUtils
using StatsBase: mean
using Random: shuffle
include("../../src/pose.jl"); # autogenerated from: "../src/pose.jl"
include("plotting.jl"); # autogenerated from: "src/plotting.jl"

# Load the environment and poses
include("house_expo_data.jl"); # autogenerated from: "src/house_expo_data.jl"

include("../../src/cuda_raycaster_line_map_b.jl"); # autogenerated from: "../src/cuda_raycaster_line_map_b.jl"

_fov = 2π
_num_a = 361
_as  = [range(-_fov/2, _fov/2, _num_a)...];

_segs_  = CuArray(stack(Vector.(_segs)));
_boxes_ = CuArray(stack(Vector.(_boxes)));
_ps_    = CuArray(stack(Vector.(_ps)));
_as_    = CuArray(_as);


# Todo: This should be computed in the data file, but
#       it also depens on `fov` so ...whatever
zs_ = cast_cu(_ps_, vcat(_segs_, _boxes_); fov=_fov)
_zs = unstack(Array(zs_));
_ys = [polar_inv(z,_as) for z in _zs]

print("""
_segs_   $(typeof(_segs_))
_boxes_  $(typeof(_boxes_))
_ps_     $(typeof(_ps_))
_as_     $(typeof(_as_))

_fov     $(typeof(_fov))
_as      $(typeof(_as))
_zs      $(typeof(_zs))
_ys      $(typeof(_ys))
""")

push!(LOAD_PATH, ENV["probcomp"]*"/Gen-Distribution-Zoo/src")
using GenDistributionZoo: ProductDistribution, diagnormal

mvuniform = ProductDistribution(uniform);
mvuniform(zeros(2), ones(2))

"""
    p = pose_prior_model(p=nothing, x_noise=0.25, hd_noise=45.)

Model depends on global variable `_bb`.
"""
@gen function pose_prior_model(p=nothing, x_noise=0.25, hd_noise=45/360*2π, bb=_bb)
    # Todo: better signature would be to ask if p is pose or a bounding box
    if p == nothing
        x  ~ mvuniform(bb...)
        hd ~ uniform(0,2π)
    else
        x  ~ diagnormal(p.x, [x_noise, x_noise])
        hd ~ normal(p.hd, hd_noise)
    end
    return Pose(x, hd)
end;

@gen function control_prior_model(dx_noise=0.25, dhd_noise=45/360*2π)
    dx  ~ diagnormal([0;0], [dx_noise, dx_noise])
    dhd ~ normal(0, dhd_noise)
    return Control(dx, dhd)
end;

"""
    q = motion_model(p, u, x_noise, hd_noise)

Sample a new pose `q` given the previous pose `p`,
some control data `u = Control(dx, dhd)`, and noise levels
`x_noise` and `hd_noise`.
"""
@gen function motion_model(p, u, x_noise, hd_noise)
    dx, dhd = u.dx, u.dhd
    x   ~ diagnormal(p.x  + dx , [x_noise, x_noise])
    hd  ~ normal(p.hd + dhd, hd_noise)
    return Pose(x, hd)
end;

include("sensor_distribution.jl"); # autogenerated from: "src/sensor_distribution.jl"

@gen function sensor_model(p, segs, w, s_noise, outlier, outlier_vol, zmax=100.0)
    segs_ = CuArray(stack(Vector.(_segs)))
    p_    = CuArray(Vector(p))
    ps_   = reshape(p_, 1, 3)

    zs_      = cast_cu(ps_, segs_; fov=_fov)
    as_      = CuArray(_as)
    y_tilde_ = get_ys_tilde_cu(zs_, as_, w)[1,:,:,:]

    x ~ sensordist_cu(y_tilde_, s_noise, outlier, outlier_vol)
    return x
end;
