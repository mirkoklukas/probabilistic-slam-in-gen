# # # # # # # # # # # # # # # # # # # 
#                                   # 
#   This is an auto-generated file  # 
#   based on the jupyter notebook   # 
#
#   >   ``11 - Sensor Model - CUDA accelerated.ipynb''
#
#                                   #
# # # # # # # # # # # # # # # # # # #

using CUDA

"""
    log_p = sensor_smc_logpdf_cu(x::CuArray, ys_tilde::CuArray, sig, outlier)

Evaluates the logpdf of an observation `x` (shape: `(n,2)`)
with respect to a number of different gaussian mixtures (e.g. from family
of different poses) stacked along the first dim of `ys_tilde` (k,n,m,2) ...
"""
function sensor_smc_logpdf_cu(x, ys_tilde, sig, outlier)

    n = size(ys_tilde,2)
    m = size(ys_tilde,3)

    xs = reshape(x, 1, n, 1, 2)

    # Line by line...
    # 1. Compute 1D Gaussians - (n,m,2)
    # 2. Convert to 2D gausians - (n,m)
    # 3. Convert to mixture of m 2D gausians (GM) - (n,)
    # 4. Convert to mixture of `GM` and `anywhere` (D) - (n,)
    # 5. Convert to Product of D's - ()
    log_p = gaussian_logpdf(xs, ys_tilde, sig)
    log_p = sum(log_p, dims=4)[:,:,:,1]
    log_p = logsumexp_cu(log_p .- log(m), 3)[:,:,1]
    log_p_or_any = log.((1-outlier)*exp.(log_p) .+ outlier*1.0)
    log_p = sum(log_p_or_any ,dims=2)[:,1]

    return log_p
end;

function sensor_logpdf_cu(x::CuArray, y_tilde::CuArray, sig, outlier)
    n = size(y_tilde,1)
    m = size(y_tilde,2)

    @assert size(x,1) == size(y_tilde,1)

    x = reshape(x, n, 1, 2)

    # Compute 1D Gaussians - (n,m,2)
    # Convert to 2D gausians - (n,m)
    # Convert to mixture of m 2D gausians (GM) - (n,)
    # Convert to mixture of `GM` and `anywhere` (D) - (n,)
    # Convert to Product of D's - ()
    log_p = gaussian_logpdf(x, y_tilde, sig)
    log_p = sum(log_p, dims=3)[:,:,1]
    log_p = logsumexp_cu(log_p .- log(m), 2)[:,1]
    log_p_or_any_ = log.((1-outlier)*exp.(log_p) .+ outlier*1.0)
    log_p = sum(log_p_or_any_)
    return log_p
end

using Gen
struct SensorDistribution_CUDA <: Distribution{Vector{Vector{Float64}}}
end

const sensordist_cu = SensorDistribution_CUDA()

function Gen.logpdf(::SensorDistribution_CUDA, x, y_tilde_::CuArray, sig, outlier)
    x_ = CuArray(stack(x))
    return sensor_logpdf_cu(x_, y_tilde_, sig, outlier)
end
function Gen.random(::SensorDistribution_CUDA, y_tilde_::CuArray, sig, outlier)
    n = size(y_tilde_,1)
    m = size(y_tilde_,2)

    x = Vector{Float64}[]
    for i=1:n
        if bernoulli(outlier)
            x_i = [Inf;Inf]
        else
            j = rand(1:m)
            y = Array(y_tilde_[i,j,:])
            x_i = diagnormal(y, [sig;sig])

        end
        push!(x, x_i)
    end
    return x
end

(D::SensorDistribution_CUDA)(args...) = Gen.random(D, args...)
Gen.has_output_grad(::SensorDistribution_CUDA)    = false
Gen.has_argument_grads(::SensorDistribution_CUDA) = (false, false);

include("../../src/cuda_raycaster_line_map_b.jl"); # autogenerated from: "../src/cuda_raycaster_line_map_b.jl"

function cast_cu(ps_::CuArray, segs_::CuArray; zmax::Float64=Inf)
    z_ = zmax*CUDA.ones(size(ps_, 1), 361)
    cast_cu!(z_,segs_,ps_)
    return z_
end

@gen function sensor_model_cu(p, w, s_noise, dropout)
    p_ = CuArray(Vector(p))
    zs_      = cast_cu(reshape(p_, 1,3))
    y_tilde_ = get_ys_tilde_cu(zs_, w)[1,:,:,:];

    x ~ sensordist_cu(y_tilde_, s_noise, dropout)
    return x
end
